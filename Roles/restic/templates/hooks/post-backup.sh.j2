#!/bin/bash
# Post-Backup Hook for {{ item.name }}
# Generated by Ansible - Customize as needed

# Exit status is passed as argument
EXIT_STATUS="${1:-0}"

SOURCE_NAME="{{ item.name }}"
SOURCE_PATH="{{ item.path }}"
LOG_TAG="restic-post-backup-${SOURCE_NAME}"

logger -t "${LOG_TAG}" -p user.info "Executing post-backup tasks for ${SOURCE_NAME} (backup exit: ${EXIT_STATUS})"

{% if item.start_services is defined and item.start_services | length > 0 %}
# Start services after backup (regardless of backup status)
{% for service in item.start_services %}
logger -t "${LOG_TAG}" -p user.info "Starting service: {{ service }}"
systemctl start {{ service }} || logger -t "${LOG_TAG}" -p user.warning "Failed to start {{ service }}"
{% endfor %}
{% endif %}

{% if item.database_dump is defined and item.database_dump.enabled %}
# Cleanup database dumps
BACKUP_DIR="/var/backups"
{% if item.database_dump.type == 'mysql' %}
logger -t "${LOG_TAG}" -p user.info "Cleaning up MySQL dump"
rm -f "${BACKUP_DIR}/mysql-{{ item.name }}-dump.sql"
{% elif item.database_dump.type == 'postgresql' %}
logger -t "${LOG_TAG}" -p user.info "Cleaning up PostgreSQL dump"
rm -f "${BACKUP_DIR}/postgres-{{ item.name }}-dump.sql"
{% endif %}
{% endif %}

{% if item.post_backup_commands is defined and item.post_backup_commands | length > 0 %}
# Custom post-backup commands (only on success)
if [ "${EXIT_STATUS}" = "0" ]; then
{% for cmd in item.post_backup_commands %}
    logger -t "${LOG_TAG}" -p user.info "Running: {{ cmd }}"
    {{ cmd }} || logger -t "${LOG_TAG}" -p user.warning "Command failed (non-fatal): {{ cmd }}"
{% endfor %}
fi
{% endif %}

# Log completion
if [ "${EXIT_STATUS}" = "0" ]; then
    logger -t "${LOG_TAG}" -p user.info "Post-backup tasks completed successfully for ${SOURCE_NAME}"
else
    logger -t "${LOG_TAG}" -p user.warning "Post-backup tasks completed for ${SOURCE_NAME} (backup had errors)"
fi

exit 0
